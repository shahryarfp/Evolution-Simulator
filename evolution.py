# -*- coding: utf-8 -*-
"""evolution.ipynb

Automatically generated by Colab.

## Imports
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation, PillowWriter
from matplotlib.patches import Circle, Wedge
from IPython.display import HTML, display
import random
import numba
import os

"""## Main Logic

### Hyperparameters
"""

# Simulation parameters
GRID_W, GRID_H = 50, 50
POP_SIZE       = 300
STEPS          = 200
GENS           = 150

# Visualization parameters
SHOW_EVERY     = 50

# Agent neural network parameters
HIDDEN_SIZE    = 16

# Selection area parameters
CENTER_X, CENTER_Y = GRID_W / 2, GRID_H / 2
RADIUS         = min(GRID_W, GRID_H) / 4

# --- GENOME AND NETWORK CALCULATIONS ---
SENSORS        = 8 + 16 + 1 + 1 + 1 + 1  # 8 (ring1) + 16 (ring2) + age + pos_x + pos_y + random
L1, L2, L3     = HIDDEN_SIZE, HIDDEN_SIZE, HIDDEN_SIZE
OUTPUTS        = 4 # Move N, S, E, W
WEIGHTS_COUNT  = SENSORS*L1 + L1*L2 + L2*L3 + L3*OUTPUTS
HEX_PER_WT     = 4 # 2 bytes (u16) = 4 hex digits
GENOME_LEN     = WEIGHTS_COUNT * HEX_PER_WT
MUT_RATE       = 1 / GENOME_LEN * 2 # Chance for a hex digit to mutate

@numba.njit(cache=True)
def decode_genome_to_weights(genome_as_bytes):
    """
    Decodes a byte representation of a genome into weight matrices.
    """
    ints = np.frombuffer(genome_as_bytes, dtype=np.uint16).astype(np.float32)
    weights = (ints / np.float32(65535.0)) * np.float32(2.0) - np.float32(1.0)

    idx = 0
    W1 = weights[idx : idx + SENSORS * L1].reshape(SENSORS, L1)
    idx += SENSORS * L1
    W2 = weights[idx : idx + L1 * L2].reshape(L1, L2)
    idx += L1 * L2
    W3 = weights[idx : idx + L2 * L3].reshape(L2, L3)
    idx += L2 * L3
    W4 = weights[idx : idx + L3 * OUTPUTS].reshape(L3, OUTPUTS)

    return W1, W2, W3, W4

def mutate_genome(genome):
    mutated_genome = list(genome)
    for i in range(len(mutated_genome)):
        if random.random() < MUT_RATE:
            mutated_genome[i] = random.choice('0123456789abcdef')
    return ''.join(mutated_genome)

class Agent:
    def __init__(self, genome=None):
        self.genome = genome or self.random_genome()
        self.genome_bytes = bytes.fromhex(self.genome)
        self.x = 0
        self.y = 0
        self.age = 0
        self.reset()

    def reset(self):
        self.x = random.randrange(GRID_W)
        self.y = random.randrange(GRID_H)
        self.age = 0

    @staticmethod
    def random_genome():
        return ''.join(random.choice('0123456789abcdef') for _ in range(GENOME_LEN))

@numba.njit(cache=True)
def get_sensor_ring_values(x, y, grid, ring_dist):
    sensors = np.zeros(8 * ring_dist, dtype=np.int8)
    idx = 0
    for dx in range(-ring_dist, ring_dist + 1):
        for dy in range(-ring_dist, ring_dist + 1):
            if max(abs(dx), abs(dy)) != ring_dist:
                continue

            xx, yy = x + dx, y + dy
            if 0 <= xx < GRID_W and 0 <= yy < GRID_H and grid[yy, xx] > 0:
                sensors[idx] = 1
            idx += 1
    return sensors

@numba.njit(cache=True)
def simulation_step(pop_size, positions, ages, grid, all_W1, all_W2, all_W3, all_W4):
    agent_indices = np.arange(pop_size)
    np.random.shuffle(agent_indices)

    for i in agent_indices:
        x, y = int(positions[i, 0]), int(positions[i, 1])

        ring1_sensors = get_sensor_ring_values(x, y, grid, 1)
        ring2_sensors = get_sensor_ring_values(x, y, grid, 2)

        internal_sensors = np.array([
            ages[i] / STEPS,
            x / GRID_W,
            y / GRID_H,
            np.random.uniform(-1.0, 1.0)
        ], dtype=np.float32)

        all_sensors = np.concatenate((ring1_sensors.astype(np.float32),
                                      ring2_sensors.astype(np.float32),
                                      internal_sensors))

        h1 = np.tanh(all_sensors @ all_W1[i])
        h2 = np.tanh(h1 @ all_W2[i])
        h3 = np.tanh(h2 @ all_W3[i])
        out = h3 @ all_W4[i]
        move = np.argmax(out)

        dx, dy = 0, 0
        if move == 0: dx = -1
        elif move == 1: dx = 1
        elif move == 2: dy = 1
        elif move == 3: dy = -1

        new_x, new_y = x + dx, y + dy

        if 0 <= new_x < GRID_W and 0 <= new_y < GRID_H and grid[new_y, new_x] == 0:
            grid[y, x] = 0
            grid[new_y, new_x] = 1
            positions[i, 0] = new_x
            positions[i, 1] = new_y

    ages += 1

def run_generation_simulation(pop):
    positions = np.array([(a.x, a.y) for a in pop], dtype=np.float32)
    ages = np.array([a.age for a in pop], dtype=np.int32)

    all_weights = [decode_genome_to_weights(a.genome_bytes) for a in pop]
    all_W1 = np.array([w[0] for w in all_weights], dtype=np.float32)
    all_W2 = np.array([w[1] for w in all_weights], dtype=np.float32)
    all_W3 = np.array([w[2] for w in all_weights], dtype=np.float32)
    all_W4 = np.array([w[3] for w in all_weights], dtype=np.float32)

    traj = [np.copy(positions)]
    grid = np.zeros((GRID_H, GRID_W), dtype=np.int8)
    for x, y in positions.astype(int):
        grid[y, x] = 1

    for _ in range(STEPS):
        simulation_step(POP_SIZE, positions, ages, grid, all_W1, all_W2, all_W3, all_W4)
        traj.append(np.copy(positions))

    return traj

def plot_final_frame(positions, title="", selection_mode='center'):
    fig, ax = plt.subplots(figsize=(5, 5))
    pts = np.array(positions)
    ax.scatter(pts[:, 0], pts[:, 1], s=10, alpha=0.7)
    ax.set_xlim(0, GRID_W)
    ax.set_ylim(0, GRID_H)

    if selection_mode == 'center':
        circle = Circle((CENTER_X, CENTER_Y), RADIUS, edgecolor='red', fill=False, linewidth=2, ls='--')
        ax.add_patch(circle)
    elif selection_mode == 'corners':
        style = {'edgecolor': 'red', 'fill': False, 'linewidth': 2, 'ls': '--'}
        ax.add_patch(Wedge((0, 0), RADIUS, 0, 90, **style))
        ax.add_patch(Wedge((GRID_W, 0), RADIUS, 90, 180, **style))
        ax.add_patch(Wedge((GRID_W, GRID_H), RADIUS, 180, 270, **style))
        ax.add_patch(Wedge((0, GRID_H), RADIUS, 270, 360, **style))

    ax.set_title(title, fontsize=14)
    ax.set_aspect('equal')
    ax.invert_yaxis()
    plt.show()

def animate_trajectory(traj, selection_mode='center'):
    fig, ax = plt.subplots(figsize=(5, 5))
    scat = ax.scatter([], [], s=10, alpha=0.7)
    ax.set_xlim(0, GRID_W)
    ax.set_ylim(0, GRID_H)

    if selection_mode == 'center':
        circle = Circle((CENTER_X, CENTER_Y), RADIUS, edgecolor='red', fill=False, linewidth=2, ls='--')
        ax.add_patch(circle)
    elif selection_mode == 'corners':
        style = {'edgecolor': 'red', 'fill': False, 'linewidth': 2, 'ls': '--'}
        ax.add_patch(Wedge((0, 0), RADIUS, 0, 90, **style))
        ax.add_patch(Wedge((GRID_W, 0), RADIUS, 90, 180, **style))
        ax.add_patch(Wedge((GRID_W, GRID_H), RADIUS, 180, 270, **style))
        ax.add_patch(Wedge((0, GRID_H), RADIUS, 270, 360, **style))

    ax.set_aspect('equal')
    ax.invert_yaxis()

    title = ax.text(0.5, 1.05, '', transform=ax.transAxes, ha="center", fontsize=14)

    def init():
        scat.set_offsets(np.empty((0, 2)))
        title.set_text('')
        return scat, title

    def update(i):
        pts = np.array(traj[i])
        scat.set_offsets(pts)
        title.set_text(f"Step {i}")
        return scat, title

    anim = FuncAnimation(fig, update, frames=len(traj), init_func=init, interval=50, blit=True)
    plt.close(fig)
    return anim

def select_by_center_circle(population, final_positions):
    survivors = []
    for agent, pos in zip(population, final_positions):
        if (pos[0] - CENTER_X)**2 + (pos[1] - CENTER_Y)**2 <= RADIUS**2:
            survivors.append(agent)
    return survivors

def select_by_corner_quarters(population, final_positions):
    survivors = []
    for agent, pos in zip(population, final_positions):
        x, y = pos
        if (x**2 + y**2 <= RADIUS**2 or
            (x - GRID_W)**2 + y**2 <= RADIUS**2 or
            x**2 + (y - GRID_H)**2 <= RADIUS**2 or
            (x - GRID_W)**2 + (y - GRID_H)**2 <= RADIUS**2):
            survivors.append(agent)
    return survivors

def create_next_generation(survivors, pop_size):
    if not survivors:
        return [Agent() for _ in range(pop_size)]

    return [
        Agent(genome=mutate_genome(random.choice(survivors).genome))
        for _ in range(pop_size)
    ]

def run_evolution(selection_mode='center'):
    print(f"--- Running Evolution: {selection_mode.capitalize()} Selection ---")
    np.random.seed(42)
    random.seed(42)

    population = [Agent() for _ in range(POP_SIZE)]
    survivor_counts = []
    select_fn = select_by_center_circle if selection_mode == 'center' else select_by_corner_quarters

    output_dir = "output"
    os.makedirs(output_dir, exist_ok=True)

    for gen in range(1, GENS + 1):
        for a in population:
            a.reset()

        trajectory = run_generation_simulation(population)

        if gen == 1:
            plot_final_frame(trajectory[0], title="Gen 1 Â· Initial Positions", selection_mode=selection_mode)

        final_positions = trajectory[-1]
        survivors = select_fn(population, final_positions)
        survivor_counts.append(len(survivors))

        print(f"Gen {gen:2d}: {len(survivors)}/{POP_SIZE} survivors.")

        if (gen == 1 or gen % SHOW_EVERY == 0) and len(survivors) > 0:
            print(f"Creating animation for Gen {gen}...")
            anim = animate_trajectory(trajectory, selection_mode=selection_mode)
            anim_path = os.path.join(output_dir, f"gen_{gen}_{selection_mode}.gif")
            anim.save(anim_path, writer=PillowWriter(fps=20))
            print(f"Animation saved to '{anim_path}'")
            display(HTML(anim.to_jshtml()))

        population = create_next_generation(survivors, POP_SIZE)

    print("\n--- Simulation Finished ---")
    plt.figure(figsize=(10, 5))
    plt.plot(range(1, GENS + 1), survivor_counts, marker='o', linestyle='-')
    plt.title(f"Survivor Count Over Generations ({selection_mode.capitalize()} Selection)")
    plt.xlabel("Generation")
    plt.ylabel("Number of Survivors")
    plt.grid(True, which='both', linestyle='--', linewidth=0.5)
    plt.xlim(1, GENS)
    plt.ylim(0, POP_SIZE)
    plot_path = os.path.join(output_dir, f"survivors_plot_{selection_mode}.png")
    plt.savefig(plot_path)
    print(f"Survivor plot saved to '{plot_path}'")
    plt.show()

"""## Corners Evolution"""

run_evolution(selection_mode='corners')

"""## Center Evolution"""

run_evolution(selection_mode='center')

